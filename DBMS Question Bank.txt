-----------------------------------------------------------------------------
Exp 3 : Converting RGB color to gray scale image
------------------------------------------------------------------------------
import cv2
import matplotlib.pyplot as plt

image = cv2.imread()

# Display original image
plt.figure(figsize=(8, 6))
plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
plt.title('Original Image')
plt.show()

# Convert to grayscale
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Display grayscale image
plt.figure(figsize=(8, 6))
plt.imshow(gray_image, cmap='gray')
plt.title('Grayscale Image')
plt.show()


-------------------------------------------------------------------------------
Exp 4 : Utilizing OpenCV to implement simple & Adaptive thresholding
-------------------------------------------------------------------------------
import cv2 as cv
import numpy as np
from matplotlib import pyplot as plt

# Read the image in grayscale
img = cv.imread(r"C:\Users\ssidh\Downloads\season-1.jpg", cv.IMREAD_GRAYSCALE)
assert img is not None, "file could not be read, check with os.path.exists()"

# Apply median blur
img = cv.medianBlur(img, 5)

# Apply adaptive Gaussian thresholding
thresh_img = cv.adaptiveThreshold(img, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2)

# Set figure size
plt.figure(figsize=(12, 6))

# Display the original image
plt.subplot(1, 2, 1)
plt.imshow(img, 'gray')
plt.title('Original Image')
plt.xticks([]), plt.yticks([])

# Display the thresholded image
plt.subplot(1, 2, 2)
plt.imshow(thresh_img, 'gray')
plt.title('Adaptive Gaussian Thresholding')
plt.xticks([]), plt.yticks([])

plt.show()


-------------------------------------------------------------------------------
Exp 6 : To perform edge detection using OpenCV
-------------------------------------------------------------------------------
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load the image
image_path = r"C:\Users\ssidh\Downloads\season-1.jpg"  # Replace with your image path
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

# Function to display images
def display_images(images, titles):
    plt.figure(figsize=(12, 6))
    
    # Display the original image
    plt.subplot(1, 2, 1)
    plt.imshow(images[0], cmap='gray')
    plt.title(titles[0])
    plt.axis('off')
    
    # Display the Canny edge detection result
    plt.subplot(1, 2, 2)
    plt.imshow(images[1], cmap='gray')
    plt.title(titles[1])
    plt.axis('off')
    
    plt.show()

# Canny Edge Detection
canny_edges = cv2.Canny(image, 200, 100)

# Display the original image and the Canny edge detection result
display_images([image, canny_edges], ['Original Image', 'Canny Edge Detection'])

-------------------------------------------------------------------------------
Exp 8 : Circle Detection using Hough Transform
-------------------------------------------------------------------------------
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load and preprocess the image
image = cv2.imread(r"C:\Users\ssidh\Downloads\eye.jpg")
gray = cv2.GaussianBlur(cv2.cvtColor(image, cv2.COLOR_BGR2GRAY), (15, 15), 0)

# Try enhancing contrast to make circles more distinct
gray = cv2.equalizeHist(gray)

# Detect circles
circles = cv2.HoughCircles(
    gray, cv2.HOUGH_GRADIENT, dp=1.2, minDist=20,
    param1=120, param2=30, minRadius=23, maxRadius=50
)

# Draw detected circles
if circles is not None:
    for x, y, r in np.round(circles[0, :]).astype("int"):
        cv2.circle(image, (x, y), r, (0, 255, 0), 4)
        cv2.circle(image, (x, y), 2, (0, 0, 255), 3)

# Display result
plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.show()



















